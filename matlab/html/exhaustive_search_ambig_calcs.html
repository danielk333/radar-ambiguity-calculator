
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>exhaustive_search_ambig_calcs</title><meta name="generator" content="MATLAB 9.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-10-15"><meta name="DC.source" content="exhaustive_search_ambig_calcs.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">TEST BY GENERATING A PERFECT SYMMETRIC ARRAY</a></li></ul></div><pre class="codeinput">clear; close <span class="string">all</span>;
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%%%%%%%%%%%%%%%%</span>
<span class="comment">%This is for JONES radar</span>
<span class="comment">%%%%%%%%%%%%%%%%</span>
C = 299.792458;<span class="comment">% Speed of light in Mega m/s</span>
F0 = 31;<span class="comment">% 47.0 MHz</span>
lambda0=C/F0;<span class="comment">% meter</span>


xy = [<span class="keyword">...</span>
    0, 2;<span class="keyword">...</span>
    0, -2.5;<span class="keyword">...</span>
    -2, 0;<span class="keyword">...</span>
    2.5, 0;<span class="keyword">...</span>
    0, 0];
xpos = zeros(size(xy,1),1)*lambda0;
ypos = zeros(size(xy,1),1)*lambda0;
zpos = zeros(size(xy,1),1)*lambda0;




c0 = 2.99792e8;

<span class="comment">%%%%%%%%%%%%%%%%</span>
<span class="comment">%THIS IS FOR PANSY RADAR</span>
<span class="comment">%%%%%%%%%%%%%%%%%</span>
<span class="comment">%</span>
<span class="comment">% f0 = 46.5e6;</span>
<span class="comment">% % f0 = 50e6;</span>
<span class="comment">% lambda0 = c0/f0;</span>
<span class="comment">%</span>

<span class="comment">%</span>
<span class="comment">% load('subarrypos101.txt')</span>
<span class="comment">%</span>
<span class="comment">% core = find(sqrt(sum(subarrypos101.^2,2)) &lt;= 50);</span>
<span class="comment">% outlier = find(sqrt(sum(subarrypos101.^2,2)) &gt; 50);</span>
<span class="comment">%</span>
<span class="comment">% subarrypos101(outlier,:) = [];</span>
<span class="comment">%</span>
<span class="comment">% subarrypos101(6,:) = subarrypos101(end,:);</span>
<span class="comment">% subarrypos101(end,:) = [0,0];</span>
<span class="comment">%</span>

<span class="comment">%%%%%%%%%%%%%%%%</span>
<span class="comment">%THIS IS FOR EISCAT 3D</span>
<span class="comment">%%%%%%%%%%%%%%%%</span>
<span class="comment">%</span>
<span class="comment">% C = 299.792458;% Speed of light in Mega m/s</span>
<span class="comment">% F0 = 233;% 47.0 MHz</span>
<span class="comment">% lambda0=C/F0;% meter</span>
<span class="comment">%</span>
<span class="comment">% xy = subarrypos101./lambda0;</span>
<span class="comment">%</span>
<span class="comment">% xpos = zeros(size(xy,1),1)*lambda0;</span>
<span class="comment">% ypos = zeros(size(xy,1),1)*lambda0;</span>
<span class="comment">% zpos = zeros(size(xy,1),1)*lambda0;</span>
<span class="comment">%</span>

<span class="comment">%%%%%%%%%%%%%%%%</span>
<span class="comment">%THIS is for MU RADAR</span>
<span class="comment">%%%%%%%%%%%%%%%%</span>
<span class="comment">% C = 299.792458;% Speed of light in Mega m/s</span>
<span class="comment">% F0 = 46.5;% 46.5 MHz</span>
<span class="comment">% lambda0=C/F0;% meter</span>
<span class="comment">%</span>
<span class="comment">% load('/home/danielk/IRF/IRF_GITLAB/METEOR_MUSIC_MC_ORB_DISTRIBUTION/DEPLOY/xy_muant25.mat')</span>
<span class="comment">% [xpos,ypos,zpos] = muantennas();</span>
<span class="comment">%</span>
<span class="comment">% INDEX_OF_ASSYMETRIC = 1:4:21;</span>
<span class="comment">% INDEX_OF_SYMETRIC = 1:25;</span>
<span class="comment">% INDEX_OF_SYMETRIC(INDEX_OF_ASSYMETRIC) = [];</span>
<span class="comment">%</span>
<span class="comment">% xpos = xpos(INDEX_OF_SYMETRIC,:);</span>
<span class="comment">% ypos = ypos(INDEX_OF_SYMETRIC,:);</span>
<span class="comment">% zpos = zpos(INDEX_OF_SYMETRIC,:);</span>
<span class="comment">% xy = xy(INDEX_OF_SYMETRIC,:);</span>

<span class="comment">%%%%%%%%%%%%%%%%</span>
<span class="comment">% THIS IS FOR JICAMARCA RADAR</span>
<span class="comment">%%%%%%%%%%%%%%%%</span>
<span class="comment">% d = 144;</span>
<span class="comment">% xy = [-d/lambda0/2,-d/lambda0/2;...</span>
<span class="comment">%     d/lambda0/2,-d/lambda0/2;...</span>
<span class="comment">%     d/lambda0/2,d/lambda0/2;...</span>
<span class="comment">%     -(36+36/2)/lambda0,(36*3+36/2)/lambda0;...</span>
<span class="comment">%     -(36+36/2)/lambda0,(36*2+36/2)/lambda0;...</span>
<span class="comment">%     -(36*2+36/2)/lambda0,(36*2+36/2)/lambda0];</span>
<span class="comment">% xpos = zeros(6,1)*lambda0;</span>
<span class="comment">% ypos = zeros(6,1)*lambda0;</span>
<span class="comment">% zpos = zeros(6,1)*lambda0;</span>

<span class="comment">%%%%%%%%%%%%%%%%</span>
</pre><h2 id="2">TEST BY GENERATING A PERFECT SYMMETRIC ARRAY</h2><pre class="codeinput"><span class="comment">%%%%%%%%%%%%%%%%</span>
<span class="comment">% d = 3;</span>
<span class="comment">% % xy = [d,0;...</span>
<span class="comment">% %     -d,0;...</span>
<span class="comment">% %     0,d;...</span>
<span class="comment">% %     0,-d;...</span>
<span class="comment">% %     d/sqrt(2),d/sqrt(2);...</span>
<span class="comment">% %     -d/sqrt(2),d/sqrt(2);...</span>
<span class="comment">% %     d/sqrt(2),-d/sqrt(2);...</span>
<span class="comment">% %     -d/sqrt(2),-d/sqrt(2);...</span>
<span class="comment">% %     0,0];</span>
<span class="comment">%</span>
<span class="comment">% xy = [d*cosd(67.5),d*sind(67.5);...</span>
<span class="comment">%     d*cosd(-67.5),d*sind(-67.5);...</span>
<span class="comment">%     d*cosd(112.5),d*sind(112.5);...</span>
<span class="comment">%     d*cosd(-112.5),d*sind(-112.5);...</span>
<span class="comment">%     0,0];</span>
<span class="comment">% xpos = zeros(5,1);</span>
<span class="comment">% ypos = zeros(5,1);</span>
<span class="comment">% zpos = zeros(5,1);</span>
<span class="comment">%</span>
<span class="comment">% xy = [d*cosd(67.5),d*sind(67.5);...</span>
<span class="comment">%     d*cosd(112.5),d*sind(112.5);...</span>
<span class="comment">%     0,-d;...</span>
<span class="comment">%     0,0];</span>
<span class="comment">% xpos = (zeros(4,4) + repmat([0,0,-d/6,d/6],4,1) + repmat(xy(:,1),1,4))*lambda0;</span>
<span class="comment">% ypos = (zeros(4,4) + repmat([-d/6,d/6,0,0],4,1) + repmat(xy(:,2),1,4))*lambda0;</span>
<span class="comment">% zpos = zeros(4,4);</span>


<span class="comment">% MP_tol = 1e-3</span>
<span class="comment">% MP_tol = 3.5e-2</span>
MP_tol = 1e-1
<span class="comment">% MP_tol = 1.13e-1</span>



gain_yagi = 7.24;
gain_yagi_base = 10^(gain_yagi/10);
<span class="comment">%figure size configurations</span>
axis_font_size = 18;
title_font_size = 16;
legend_font_size = 14;

xant = xpos/lambda0;
yant = ypos/lambda0;

Zn = size(zpos,2); <span class="comment">%subgroup size</span>

<span class="comment">% DO NOT COUNT THE LAST GROUP AS IT IS DEFINED AS THE ORIGIN</span>
Sn = size(zpos,1); <span class="comment">%sensorgroups</span>
Sn = Sn - 1;

<span class="comment">% Sn = 4;</span>

r=zeros(3,Zn,Sn);
R=zeros(3,Sn);
R(:,:) = [xy(1:Sn,1).'; xy(1:Sn,2).'; (xy(1:Sn,1).')*0];

<span class="keyword">for</span> i=1:Sn
    r(:,:,i) = [xpos(i,:); ypos(i,:); zpos(i,:)]./lambda0;
<span class="keyword">end</span>


rho=zeros(3,Zn,Sn);
<span class="keyword">for</span> i=1:Sn
    rho(:,:,i) = r(:,:,i) - repmat(R(:,i),1,Zn);
<span class="keyword">end</span>





k=@(th,ph) [cos(th).*sin(ph); sin(th).*sin(ph); cos(ph)];

<span class="comment">%calculate the linear coefficients</span>
K = zeros(Sn,1);
<span class="keyword">for</span> i=1:Sn
    Rni = norm(R(:,i));
    K(i) = R(1,i)^2/Rni + R(2,i)^2/Rni + R(3,i)^2/Rni;
<span class="keyword">end</span>



<span class="comment">% calculate the base numbers</span>
n0 = floor(2*K);

<span class="comment">% k's from 1 to 2n0+1</span>
k_length = 2*n0+1;

<span class="comment">%calculate all the integer planes</span>
r_jk =@(j,k) (n0(j)+1-k)/K(j);
p0_jk =@(j,k) [r_jk(j,k)*R(1,j)/norm(R(:,j)); r_jk(j,k)*R(2,j)/norm(R(:,j)); r_jk(j,k)*R(3,j)/norm(R(:,j))];
nvec_j = @(j) R(:,j)./norm(R(:,j));
I_j =@(j,x,y,z) R(1,j)*x + R(2,j)*y + R(3,j)*z;

<span class="comment">%create all possible permutations from 3 first sets of planes</span>

PERMS_n = prod(k_length(1:3));
PERMS_J = zeros(PERMS_n,3);
cnt = 0;
<span class="keyword">for</span> i1=1:k_length(1)
    <span class="keyword">for</span> i2=1:k_length(2)
        <span class="keyword">for</span> i3=1:k_length(3)
            cnt = cnt + 1;
            PERMS_J(cnt,:) = [i1,i2,i3];
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

fprintf(<span class="string">'First intersection calculation: %i permutations of 3 planes\n'</span>,PERMS_n);

<span class="comment">%3 first sets of planes</span>
I = [1,2,3];

<span class="comment">%start looping over all combinations</span>

pinv_norm = zeros(PERMS_n,1);
intersection_line = zeros(3,PERMS_n);
<span class="keyword">parfor</span> j=1:PERMS_n
    <span class="comment">%intersection matrix for planes J from groups I</span>

    J = PERMS_J(j,:);

    W_matrix = zeros(length(I),3);
    b_vector = zeros(length(I),1);
    <span class="keyword">for</span> i=1:length(I)
        W_matrix(i,:) = nvec_j(I(i)).';
        b_vector(i) = -dot(nvec_j(I(i)),p0_jk(I(i),J(i)));
    <span class="keyword">end</span>

    <span class="comment">% solution_check</span>
    Moore_Penrose_solution_check = W_matrix*pinv( W_matrix )*b_vector - b_vector;
    intersection_line(:,j) = pinv( W_matrix )*b_vector;
    pinv_norm(j) = norm(Moore_Penrose_solution_check);

<span class="keyword">end</span>

intersection_line_norm = sqrt(sum(intersection_line.^2,1)).';

intersections3_inds = find(pinv_norm &lt; MP_tol &amp; intersection_line_norm &lt;= 2 &amp; intersection_line_norm ~= 0);
intersections3_n = length(intersections3_inds)
intersections3 =  PERMS_J(intersections3_inds,:);

SURVIVORS = zeros(Sn-2,1);
SURVIVORS(1) = intersections3_n;



intersections_n = intersections3_n;
intersections_inds = intersections3_inds;
intersections =  PERMS_J(intersections_inds,:);
intersections_integers = R.'*intersection_line(:,intersections_inds.');

<span class="comment">%%%%% STEP 2</span>

<span class="keyword">for</span> ii=4:Sn



    PERMS_J_base = PERMS_J;

    <span class="comment">%create all possible permutations from ii first sets of planes with only the</span>
    <span class="comment">%surviving set + all new</span>
    <span class="comment">%and recursibvly iterate</span>

    PERMS_n = intersections_n*k_length(ii);

    fprintf(<span class="string">'Starting plane intersections for new sensor %i of %i with %i permutations on %i remaining solutions\n'</span>,ii,Sn,PERMS_n, intersections_n);

    PERMS_J = zeros(PERMS_n,ii);
    cnt = 0;
    <span class="keyword">for</span> iperm=1:intersections_n
        <span class="keyword">for</span> i_add=1:k_length(ii)
            cnt = cnt + 1;
            PERMS_J(cnt,:) = [PERMS_J_base(intersections_inds(iperm),:), i_add];
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">%4 first sets of planes</span>
    I = [1:ii];

    <span class="comment">%start looping over all combinations</span>

    pinv_norm = zeros(PERMS_n,1);
    intersection_line = zeros(3,PERMS_n);
    <span class="keyword">parfor</span> j=1:PERMS_n
        <span class="comment">%intersection matrix for planes J from groups I</span>

        J = PERMS_J(j,:);

        W_matrix = zeros(length(I),3);
        b_vector = zeros(length(I),1);
        <span class="keyword">for</span> i=1:length(I)
            W_matrix(i,:) = nvec_j(I(i)).';
            b_vector(i) = -dot(nvec_j(I(i)),p0_jk(I(i),J(i)));
        <span class="keyword">end</span>

        <span class="comment">% solution_check</span>
        Moore_Penrose_solution_check = W_matrix*pinv( W_matrix )*b_vector - b_vector;
        intersection_line(:,j) = pinv( W_matrix )*b_vector;
        pinv_norm(j) = norm(Moore_Penrose_solution_check);

    <span class="keyword">end</span>

    intersections_inds = find(pinv_norm &lt; MP_tol);
    intersections_n = length(intersections_inds);
    intersections =  PERMS_J(intersections_inds,:);
    intersections_integers = R.'*intersection_line(:,intersections_inds.');

    SURVIVORS(ii-2) = intersections_n;

<span class="keyword">end</span>

intersections__last = intersections_n

intersections_integers_complete = [zeros(1,size(intersections_integers,2)); intersections_integers];

ambiguity_distances_INT_FORM_MAT = abs(intersections_integers_complete - round(intersections_integers_complete));
ambiguity_distances_INT_FORM_mean = mean(ambiguity_distances_INT_FORM_MAT,1)
ambiguity_distances_WAVE_FORM_MAT = exp(1i*2*pi*intersections_integers_complete) - exp(1i*2*pi*round(intersections_integers_complete));
ambiguity_distances_WAVE_FORM = sqrt(sum(ambiguity_distances_WAVE_FORM_MAT.*conj(ambiguity_distances_WAVE_FORM_MAT),1))

fign = 0;



el0 = 50;
az0 = 270;
k0x = sind(az0)*cosd(el0);
k0y = cosd(az0)*cosd(el0);
k0z = sind(el0);
k0 = [k0x; k0y; k0z];

cutoff_ph_ang = 90*pi/180;


<span class="comment">%find all s-lines that intersect with the cap by range check</span>
cap_intersections_of_slines = repmat([k0x; k0y],1,length(intersections_inds)) - intersection_line(1:2,intersections_inds);
cap_intersections_of_slines = sqrt(sum(cap_intersections_of_slines.^2,1));
cap_intersections_of_slines = cap_intersections_of_slines &lt;= sin(cutoff_ph_ang);
cap_intersections_of_slines = find(cap_intersections_of_slines);

<span class="comment">%from knowing what lines intersect with cap, find all possible DOA ambigs</span>
<span class="comment">%that are part of this</span>

s_sel = intersection_line(1:3,intersections_inds(cap_intersections_of_slines));

k_finds = zeros(size(s_sel));
k_finds(1:2,:) = repmat([k0x; k0y],1,size(s_sel,2)) - s_sel(1:2,:);
k_finds(3,:) = sqrt(1- k_finds(1,:).^2 - k_finds(2,:).^2 );

SUBGROUP_signal=@(k) exp ( -1i*2*pi*( xy(:,1)*k(1) +<span class="keyword">...</span>
                                      xy(:,2)*k(2) ) );



ambiguity_distances_EXPLICIT = zeros(1,size(k_finds,2));
ambiguity_normal_EXPLICIT = zeros(size(xy,1),size(k_finds,2));
<span class="keyword">for</span> i = 1:size(k_finds,2)
    ambiguity_distances_EXPLICIT(1,i) = norm(SUBGROUP_signal(k0) - SUBGROUP_signal(k_finds(:,i)));
    ambiguity_normal_EXPLICIT(:,i) = (SUBGROUP_signal(k0) - SUBGROUP_signal(k_finds(:,i)))/ambiguity_distances_EXPLICIT(1,i);
<span class="keyword">end</span>
ambiguity_distances_EXPLICIT
ambiguity_normal_EXPLICIT


tick_font_size = 18;

fign = fign + 1; figure(fign); clf;
<span class="comment">% set( gcf, 'Color', 'White', 'Unit', 'Normalized', ...</span>
<span class="comment">%     'Position', [0.1,0.1,0.8,0.6] ) ;</span>
<span class="comment">% - Build title axes and title.</span>
<span class="comment">% axes( 'Position', [0, 0.95, 1, 0.05] ) ;</span>
<span class="comment">% set( gca, 'Color', 'None', 'XColor', 'White', 'YColor', 'White' ) ;</span>

subplot(1,1,1);
hold <span class="string">on</span>
h = plot(xy(:,1)*lambda0,xy(:,2)*lambda0, <span class="string">'ob'</span>);
<span class="keyword">for</span> i=1:(size(xy,1))
plot(xant(i,:)*lambda0, yant(i,:)*lambda0, <span class="string">'*'</span>,<span class="string">'color'</span>,[.8,.6,.6]);
<span class="keyword">if</span> size(yant,2) &gt; 1
K = convhull(xant(i,:)*lambda0, yant(i,:)*lambda0);
plot(xant(i,K)*lambda0, yant(i,K)*lambda0, <span class="string">'-k'</span>);
<span class="keyword">end</span>
<span class="keyword">end</span>
hold <span class="string">off</span>
<span class="comment">% axis('equal')</span>
lh = legend(<span class="string">'Sensor position'</span>,<span class="string">'Subgroup antennas'</span>);
xh = xlabel(<span class="string">'x [m]'</span>);
yh = ylabel(<span class="string">'y [m]'</span>);
th = title(<span class="string">'MU-radar sensor configuration'</span>);
set([xh,yh,th,lh],<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>,<span class="string">'fontsize'</span>,axis_font_size+8)
axis <span class="string">equal</span>

ax = ancestor(h, <span class="string">'axes'</span>);
ax.XAxis.FontSize = tick_font_size;
ax.YAxis.FontSize = tick_font_size;


fign = fign + 1; figure(fign); clf;
plot(xant', yant', <span class="string">'*'</span>,<span class="string">'color'</span>,[.8,.6,.6]);
hold <span class="string">on</span>
plot(xy(:,1),xy(:,2), <span class="string">'ob'</span>);
hold <span class="string">off</span>
axis(<span class="string">'equal'</span>)



fign = fign + 1; figure(fign); clf;
<span class="comment">% plot(xant', yant', '*');</span>
<span class="comment">% hold on</span>
plot(xy(:,1),xy(:,2), <span class="string">'o'</span>);
<span class="comment">% hold off</span>
axis(<span class="string">'equal'</span>)


fign = fign + 1; figure(fign); clf;
set( gcf, <span class="string">'Color'</span>, <span class="string">'White'</span>, <span class="string">'Unit'</span>, <span class="string">'Normalized'</span>, <span class="keyword">...</span>
    <span class="string">'Position'</span>, [0.1,0.1,0.8,0.6] ) ;
<span class="comment">% - Build title axes and title.</span>
axes( <span class="string">'Position'</span>, [0, 0.95, 1, 0.05] ) ;
set( gca, <span class="string">'Color'</span>, <span class="string">'None'</span>, <span class="string">'XColor'</span>, <span class="string">'White'</span>, <span class="string">'YColor'</span>, <span class="string">'White'</span> ) ;

subplot(1,1,1);
plot(3:Sn,SURVIVORS)
xh = xlabel(<span class="string">'Number of sensors included'</span>);
yh = ylabel(<span class="string">'Number of common plane intersections'</span>);
th = title(<span class="string">'Intersection plane counts'</span>);
set([xh,yh,th],<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>,<span class="string">'fontsize'</span>,axis_font_size)


fign = fign + 1; figure(fign); clf;
set( gcf, <span class="string">'Color'</span>, <span class="string">'White'</span>, <span class="string">'Unit'</span>, <span class="string">'Normalized'</span>, <span class="keyword">...</span>
    <span class="string">'Position'</span>, [0.1,0.1,0.8,0.6] ) ;
<span class="comment">% - Build title axes and title.</span>
axes( <span class="string">'Position'</span>, [0, 0.95, 1, 0.05] ) ;
set( gca, <span class="string">'Color'</span>, <span class="string">'None'</span>, <span class="string">'XColor'</span>, <span class="string">'White'</span>, <span class="string">'YColor'</span>, <span class="string">'White'</span> ) ;

subplot(1,1,1);
plot(intersection_line(1,intersections_inds),intersection_line(2,intersections_inds),<span class="string">'.b'</span>)
xh = xlabel(<span class="string">'$s_{x}$ [1]'</span>);
yh = ylabel(<span class="string">'$s_{y}$ [1]'</span>);
th = title(<span class="string">'Intersection lines'</span>);
axis([-2,2,-2,2])
set([xh,yh,th],<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>,<span class="string">'fontsize'</span>,axis_font_size)


<span class="comment">% save('MUSIC_DOA_AMBIG_base.mat');</span>

<span class="comment">% inds_inside_circle = find(sqrt(sum(intersection_line(:,intersections_inds).^2,1)) &lt; sind(18)*2.5)</span>


fign = fign + 1; figure(fign); clf;
set( gcf, <span class="string">'Color'</span>, <span class="string">'White'</span>, <span class="string">'Unit'</span>, <span class="string">'Normalized'</span>, <span class="keyword">...</span>
    <span class="string">'Position'</span>, [0.1,0.1,0.8,0.6] ) ;
<span class="comment">% - Build title axes and title.</span>
axes( <span class="string">'Position'</span>, [0, 0.95, 1, 0.05] ) ;
set( gca, <span class="string">'Color'</span>, <span class="string">'None'</span>, <span class="string">'XColor'</span>, <span class="string">'White'</span>, <span class="string">'YColor'</span>, <span class="string">'White'</span> ) ;

subplot(1,1,1);
hold <span class="string">on</span>
<span class="keyword">for</span> S_ind = 1:length(intersections_inds)
    fprintf(<span class="string">'Starting Sind %i of %i\n'</span>,S_ind,length(intersections_inds));
    <span class="comment">% for S_ind = 3</span>
    s_point = intersection_line(:,intersections_inds(S_ind));
    s_line = repmat(s_point,1,100);
    s_line(3,:) = linspace(-sqrt(4-dot(s_point,s_point)),sqrt(4-dot(s_point,s_point)),100);
    <span class="comment">%     s_line(3,:) = linspace(0,sqrt(4-dot(s_point,s_point)),line_resolution);</span>
    <span class="keyword">if</span> S_ind == 25
        plot3(s_line(1,:),s_line(2,:),s_line(3,:),<span class="string">'.r'</span>)
    <span class="keyword">else</span>
   h = plot3(s_line(1,:),s_line(2,:),s_line(3,:),<span class="string">'.b'</span>);
    <span class="keyword">end</span>
<span class="keyword">end</span>
hold <span class="string">off</span>

xh = xlabel(<span class="string">'$s_{x}$ [1]'</span>);
yh = ylabel(<span class="string">'$s_{y}$ [1]'</span>);
zh = zlabel(<span class="string">'$s_{z}$ [1]'</span>);
th = title(<span class="string">'Solution set $\Omega$'</span>);
axis([-2,2,-2,2])
view([-143,53])
set([th],<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>,<span class="string">'fontsize'</span>,axis_font_size+6)
set([xh,yh,zh],<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>,<span class="string">'fontsize'</span>,axis_font_size+12)
ax = ancestor(h, <span class="string">'axes'</span>);
ax.XAxis.FontSize = 19;
ax.YAxis.FontSize = 19;
ax.ZAxis.FontSize = 19;



fign = fign + 1; figure(fign); clf;
set( gcf, <span class="string">'Color'</span>, <span class="string">'White'</span>, <span class="string">'Unit'</span>, <span class="string">'Normalized'</span>, <span class="keyword">...</span>
    <span class="string">'Position'</span>, [0.1,0.1,0.8,0.6] ) ;
<span class="comment">% - Build title axes and title.</span>
axes( <span class="string">'Position'</span>, [0, 0.95, 1, 0.05] ) ;
set( gca, <span class="string">'Color'</span>, <span class="string">'None'</span>, <span class="string">'XColor'</span>, <span class="string">'White'</span>, <span class="string">'YColor'</span>, <span class="string">'White'</span> ) ;

subplot(1,1,1);
hold <span class="string">on</span>
<span class="keyword">for</span> S_ind = 1:length(intersections_inds)

    s_point = intersection_line(:,intersections_inds(S_ind));
   plot(s_point(1),s_point(2),<span class="string">'.b'</span>)
   text(s_point(1)+0.1,s_point(2),sprintf(<span class="string">'%.2f'</span>,ambiguity_distances_WAVE_FORM(S_ind)));
<span class="keyword">end</span>
hold <span class="string">off</span>

xh = xlabel(<span class="string">'$s_{x}$ [1]'</span>);
yh = ylabel(<span class="string">'$s_{y}$ [1]'</span>);
th = title(<span class="string">'Solution set $\Omega$'</span>);
axis([-2,2,-2,2])
set([xh,yh,th],<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>,<span class="string">'fontsize'</span>,axis_font_size)



circ_cutoff_ph_ang_x = sin(cutoff_ph_ang)*cos(linspace(0,2*pi,100));
circ_cutoff_ph_ang_y = sin(cutoff_ph_ang)*sin(linspace(0,2*pi,100));

fign = fign + 1; figure(fign); clf;
set( gcf, <span class="string">'Color'</span>, <span class="string">'White'</span>, <span class="string">'Unit'</span>, <span class="string">'Normalized'</span>, <span class="keyword">...</span>
    <span class="string">'Position'</span>, [0.1,0.1,0.8,0.6] ) ;
<span class="comment">% - Build title axes and title.</span>
axes( <span class="string">'Position'</span>, [0, 0.95, 1, 0.05] ) ;
set( gca, <span class="string">'Color'</span>, <span class="string">'None'</span>, <span class="string">'XColor'</span>, <span class="string">'White'</span>, <span class="string">'YColor'</span>, <span class="string">'White'</span> ) ;

subplot(1,2,1);
hold <span class="string">on</span>
<span class="keyword">for</span> S_ind = 1:length(intersections_inds)

    s_point = intersection_line(:,intersections_inds(S_ind));
   plot(s_point(1),s_point(2),<span class="string">'.b'</span>)
   text(s_point(1)+0.1,s_point(2),sprintf(<span class="string">'%.2f'</span>,ambiguity_distances_WAVE_FORM(S_ind)));
<span class="keyword">end</span>
plot(k0x,k0y,<span class="string">'or'</span>)
plot(circ_cutoff_ph_ang_x ,circ_cutoff_ph_ang_y,<span class="string">'-r'</span>)
hold <span class="string">off</span>

xh = xlabel(<span class="string">'$s_{x}$ [1]'</span>);
yh = ylabel(<span class="string">'$s_{y}$ [1]'</span>);
th = title(<span class="string">'Solution set $\Omega$'</span>);
axis([-2,2,-2,2])
set([xh,yh,th],<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>,<span class="string">'fontsize'</span>,axis_font_size)

subplot(1,2,2);
hold <span class="string">on</span>
plot(k0x,k0y,<span class="string">'or'</span>)
<span class="keyword">for</span> i = 1:size(k_finds,2)
   plot(k_finds(1,i),k_finds(2,i),<span class="string">'.b'</span>)
   text(k_finds(1,i)+0.1,k_finds(2,i),sprintf(<span class="string">'%.2f'</span>,ambiguity_distances_EXPLICIT(i)));
<span class="keyword">end</span>
hold <span class="string">off</span>

xh = xlabel(<span class="string">'$k_{x}$ [1]'</span>);
yh = ylabel(<span class="string">'$k_{y}$ [1]'</span>);
th = title(<span class="string">'Explicit ambiguities $\Omega(\mathbf{k})$'</span>);
axis([-1,1,-1,1])
set([xh,yh,th],<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>,<span class="string">'fontsize'</span>,axis_font_size)
</pre><pre class="codeoutput">
MP_tol =

    0.1000

First intersection calculation: 891 permutations of 3 planes
Starting parallel pool (parpool) using the 'local' profile ...
connected to 4 workers.

intersections3_n =

    34

Starting plane intersections for new sensor 4 of 4 with 374 permutations on 34 remaining solutions

intersections__last =

    16


ambiguity_distances_INT_FORM_mean =

  Columns 1 through 7

    0.0000    0.0450    0.0900    0.0450    0.0900    0.0000    0.0450

  Columns 8 through 14

    0.0450    0.0450    0.0450    0.0000    0.0900    0.0450    0.0900

  Columns 15 through 16

    0.0450    0.0000


ambiguity_distances_WAVE_FORM =

  Columns 1 through 7

    0.0000    0.9837    1.3912    0.9837    1.3912    0.0000    0.9837

  Columns 8 through 14

    0.9837    0.9837    0.9837    0.0000    1.3912    0.9837    1.3912

  Columns 15 through 16

    0.9837    0.0000


ambiguity_distances_EXPLICIT =

    0.9837    1.3912    0.9837    0.9837    0.9837    1.3912


ambiguity_normal_EXPLICIT =

  Columns 1 through 4

   0.1941 - 0.5975i   0.1373 - 0.4225i   0.0000 - 0.0000i   0.0000 - 0.0000i
   0.2977 - 0.7188i   0.2105 - 0.5083i   0.0000 + 0.0000i   0.0000 + 0.0000i
   0.0000 + 0.0000i   0.3816 - 0.2275i   0.5396 - 0.3218i  -0.6257 - 0.0569i
   0.0000 + 0.0000i   0.1517 - 0.5288i   0.2146 - 0.7478i  -0.6805 + 0.3771i
   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i

  Columns 5 through 6

   0.1941 + 0.5975i   0.1373 + 0.4225i
   0.2977 + 0.7188i   0.2105 + 0.5083i
   0.0000 + 0.0000i   0.3816 - 0.2275i
   0.0000 + 0.0000i   0.1517 - 0.5288i
   0.0000 + 0.0000i   0.0000 + 0.0000i

Starting Sind 1 of 16
Warning: Imaginary parts of complex X, Y, and/or Z arguments ignored 
Starting Sind 2 of 16
Starting Sind 3 of 16
Starting Sind 4 of 16
Starting Sind 5 of 16
Starting Sind 6 of 16
Starting Sind 7 of 16
Starting Sind 8 of 16
Starting Sind 9 of 16
Starting Sind 10 of 16
Starting Sind 11 of 16
Starting Sind 12 of 16
Starting Sind 13 of 16
Starting Sind 14 of 16
Starting Sind 15 of 16
Starting Sind 16 of 16
Warning: Imaginary parts of complex X, Y, and/or Z arguments ignored 
</pre><img vspace="5" hspace="5" src="exhaustive_search_ambig_calcs_01.png" alt=""> <img vspace="5" hspace="5" src="exhaustive_search_ambig_calcs_02.png" alt=""> <img vspace="5" hspace="5" src="exhaustive_search_ambig_calcs_03.png" alt=""> <img vspace="5" hspace="5" src="exhaustive_search_ambig_calcs_04.png" alt=""> <img vspace="5" hspace="5" src="exhaustive_search_ambig_calcs_05.png" alt=""> <img vspace="5" hspace="5" src="exhaustive_search_ambig_calcs_06.png" alt=""> <img vspace="5" hspace="5" src="exhaustive_search_ambig_calcs_07.png" alt=""> <img vspace="5" hspace="5" src="exhaustive_search_ambig_calcs_08.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018a</a><br></p></div><!--
##### SOURCE BEGIN #####

clear; close all;
% 
% 
%%%%%%%%%%%%%%%%
%This is for JONES radar
%%%%%%%%%%%%%%%%
C = 299.792458;% Speed of light in Mega m/s
F0 = 31;% 47.0 MHz
lambda0=C/F0;% meter


xy = [...
    0, 2;...
    0, -2.5;...
    -2, 0;...
    2.5, 0;...
    0, 0];
xpos = zeros(size(xy,1),1)*lambda0;
ypos = zeros(size(xy,1),1)*lambda0;
zpos = zeros(size(xy,1),1)*lambda0;




c0 = 2.99792e8;

%%%%%%%%%%%%%%%%
%THIS IS FOR PANSY RADAR
%%%%%%%%%%%%%%%%%
%
% f0 = 46.5e6;
% % f0 = 50e6;
% lambda0 = c0/f0;
% 

% 
% load('subarrypos101.txt')
% 
% core = find(sqrt(sum(subarrypos101.^2,2)) <= 50);
% outlier = find(sqrt(sum(subarrypos101.^2,2)) > 50);
% 
% subarrypos101(outlier,:) = [];
% 
% subarrypos101(6,:) = subarrypos101(end,:);
% subarrypos101(end,:) = [0,0];
% 

%%%%%%%%%%%%%%%%
%THIS IS FOR EISCAT 3D
%%%%%%%%%%%%%%%%
%
% C = 299.792458;% Speed of light in Mega m/s
% F0 = 233;% 47.0 MHz
% lambda0=C/F0;% meter
% 
% xy = subarrypos101./lambda0;
% 
% xpos = zeros(size(xy,1),1)*lambda0;
% ypos = zeros(size(xy,1),1)*lambda0;
% zpos = zeros(size(xy,1),1)*lambda0;
% 

%%%%%%%%%%%%%%%%
%THIS is for MU RADAR
%%%%%%%%%%%%%%%%
% C = 299.792458;% Speed of light in Mega m/s
% F0 = 46.5;% 46.5 MHz
% lambda0=C/F0;% meter
% 
% load('/home/danielk/IRF/IRF_GITLAB/METEOR_MUSIC_MC_ORB_DISTRIBUTION/DEPLOY/xy_muant25.mat')
% [xpos,ypos,zpos] = muantennas();
% 
% INDEX_OF_ASSYMETRIC = 1:4:21;
% INDEX_OF_SYMETRIC = 1:25;
% INDEX_OF_SYMETRIC(INDEX_OF_ASSYMETRIC) = [];
% 
% xpos = xpos(INDEX_OF_SYMETRIC,:);
% ypos = ypos(INDEX_OF_SYMETRIC,:);
% zpos = zpos(INDEX_OF_SYMETRIC,:);
% xy = xy(INDEX_OF_SYMETRIC,:);

%%%%%%%%%%%%%%%%
% THIS IS FOR JICAMARCA RADAR
%%%%%%%%%%%%%%%%
% d = 144;
% xy = [-d/lambda0/2,-d/lambda0/2;...
%     d/lambda0/2,-d/lambda0/2;...
%     d/lambda0/2,d/lambda0/2;...
%     -(36+36/2)/lambda0,(36*3+36/2)/lambda0;...
%     -(36+36/2)/lambda0,(36*2+36/2)/lambda0;...
%     -(36*2+36/2)/lambda0,(36*2+36/2)/lambda0];
% xpos = zeros(6,1)*lambda0;
% ypos = zeros(6,1)*lambda0;
% zpos = zeros(6,1)*lambda0;

%%%%%%%%%%%%%%%%
%%% TEST BY GENERATING A PERFECT SYMMETRIC ARRAY
%%%%%%%%%%%%%%%%
% d = 3;
% % xy = [d,0;...
% %     -d,0;...
% %     0,d;...
% %     0,-d;...
% %     d/sqrt(2),d/sqrt(2);...
% %     -d/sqrt(2),d/sqrt(2);...
% %     d/sqrt(2),-d/sqrt(2);...
% %     -d/sqrt(2),-d/sqrt(2);...
% %     0,0];
% 
% xy = [d*cosd(67.5),d*sind(67.5);...
%     d*cosd(-67.5),d*sind(-67.5);...
%     d*cosd(112.5),d*sind(112.5);...
%     d*cosd(-112.5),d*sind(-112.5);...
%     0,0];
% xpos = zeros(5,1);
% ypos = zeros(5,1);
% zpos = zeros(5,1);
% 
% xy = [d*cosd(67.5),d*sind(67.5);...
%     d*cosd(112.5),d*sind(112.5);...
%     0,-d;...
%     0,0];
% xpos = (zeros(4,4) + repmat([0,0,-d/6,d/6],4,1) + repmat(xy(:,1),1,4))*lambda0;
% ypos = (zeros(4,4) + repmat([-d/6,d/6,0,0],4,1) + repmat(xy(:,2),1,4))*lambda0;
% zpos = zeros(4,4);


% MP_tol = 1e-3
% MP_tol = 3.5e-2
MP_tol = 1e-1
% MP_tol = 1.13e-1



gain_yagi = 7.24;
gain_yagi_base = 10^(gain_yagi/10);
%figure size configurations
axis_font_size = 18;
title_font_size = 16;
legend_font_size = 14;

xant = xpos/lambda0;
yant = ypos/lambda0;

Zn = size(zpos,2); %subgroup size

% DO NOT COUNT THE LAST GROUP AS IT IS DEFINED AS THE ORIGIN
Sn = size(zpos,1); %sensorgroups
Sn = Sn - 1;

% Sn = 4;

r=zeros(3,Zn,Sn);
R=zeros(3,Sn);
R(:,:) = [xy(1:Sn,1).'; xy(1:Sn,2).'; (xy(1:Sn,1).')*0];

for i=1:Sn
    r(:,:,i) = [xpos(i,:); ypos(i,:); zpos(i,:)]./lambda0;
end


rho=zeros(3,Zn,Sn);
for i=1:Sn
    rho(:,:,i) = r(:,:,i) - repmat(R(:,i),1,Zn);
end





k=@(th,ph) [cos(th).*sin(ph); sin(th).*sin(ph); cos(ph)];

%calculate the linear coefficients
K = zeros(Sn,1);
for i=1:Sn
    Rni = norm(R(:,i));
    K(i) = R(1,i)^2/Rni + R(2,i)^2/Rni + R(3,i)^2/Rni;
end



% calculate the base numbers
n0 = floor(2*K);

% k's from 1 to 2n0+1
k_length = 2*n0+1;

%calculate all the integer planes
r_jk =@(j,k) (n0(j)+1-k)/K(j);
p0_jk =@(j,k) [r_jk(j,k)*R(1,j)/norm(R(:,j)); r_jk(j,k)*R(2,j)/norm(R(:,j)); r_jk(j,k)*R(3,j)/norm(R(:,j))];
nvec_j = @(j) R(:,j)./norm(R(:,j));
I_j =@(j,x,y,z) R(1,j)*x + R(2,j)*y + R(3,j)*z;

%create all possible permutations from 3 first sets of planes

PERMS_n = prod(k_length(1:3));
PERMS_J = zeros(PERMS_n,3);
cnt = 0;
for i1=1:k_length(1)
    for i2=1:k_length(2)
        for i3=1:k_length(3)
            cnt = cnt + 1;
            PERMS_J(cnt,:) = [i1,i2,i3];
        end
    end
end

fprintf('First intersection calculation: %i permutations of 3 planes\n',PERMS_n);

%3 first sets of planes
I = [1,2,3];

%start looping over all combinations

pinv_norm = zeros(PERMS_n,1);
intersection_line = zeros(3,PERMS_n);
parfor j=1:PERMS_n
    %intersection matrix for planes J from groups I
    
    J = PERMS_J(j,:);
    
    W_matrix = zeros(length(I),3);
    b_vector = zeros(length(I),1);
    for i=1:length(I)
        W_matrix(i,:) = nvec_j(I(i)).';
        b_vector(i) = -dot(nvec_j(I(i)),p0_jk(I(i),J(i)));
    end
    
    % solution_check
    Moore_Penrose_solution_check = W_matrix*pinv( W_matrix )*b_vector - b_vector;
    intersection_line(:,j) = pinv( W_matrix )*b_vector;
    pinv_norm(j) = norm(Moore_Penrose_solution_check);
    
end

intersection_line_norm = sqrt(sum(intersection_line.^2,1)).';

intersections3_inds = find(pinv_norm < MP_tol & intersection_line_norm <= 2 & intersection_line_norm ~= 0);
intersections3_n = length(intersections3_inds)
intersections3 =  PERMS_J(intersections3_inds,:);

SURVIVORS = zeros(Sn-2,1);
SURVIVORS(1) = intersections3_n;



intersections_n = intersections3_n;
intersections_inds = intersections3_inds;
intersections =  PERMS_J(intersections_inds,:);
intersections_integers = R.'*intersection_line(:,intersections_inds.');

%%%%% STEP 2

for ii=4:Sn
    
    
    
    PERMS_J_base = PERMS_J;
    
    %create all possible permutations from ii first sets of planes with only the
    %surviving set + all new
    %and recursibvly iterate
    
    PERMS_n = intersections_n*k_length(ii);
    
    fprintf('Starting plane intersections for new sensor %i of %i with %i permutations on %i remaining solutions\n',ii,Sn,PERMS_n, intersections_n);
    
    PERMS_J = zeros(PERMS_n,ii);
    cnt = 0;
    for iperm=1:intersections_n
        for i_add=1:k_length(ii)
            cnt = cnt + 1;
            PERMS_J(cnt,:) = [PERMS_J_base(intersections_inds(iperm),:), i_add];
        end
    end
    
    %4 first sets of planes
    I = [1:ii];
    
    %start looping over all combinations
    
    pinv_norm = zeros(PERMS_n,1);
    intersection_line = zeros(3,PERMS_n);
    parfor j=1:PERMS_n
        %intersection matrix for planes J from groups I
        
        J = PERMS_J(j,:);
        
        W_matrix = zeros(length(I),3);
        b_vector = zeros(length(I),1);
        for i=1:length(I)
            W_matrix(i,:) = nvec_j(I(i)).';
            b_vector(i) = -dot(nvec_j(I(i)),p0_jk(I(i),J(i)));
        end
        
        % solution_check
        Moore_Penrose_solution_check = W_matrix*pinv( W_matrix )*b_vector - b_vector;
        intersection_line(:,j) = pinv( W_matrix )*b_vector;
        pinv_norm(j) = norm(Moore_Penrose_solution_check);
        
    end
    
    intersections_inds = find(pinv_norm < MP_tol);
    intersections_n = length(intersections_inds);
    intersections =  PERMS_J(intersections_inds,:);
    intersections_integers = R.'*intersection_line(:,intersections_inds.');
    
    SURVIVORS(ii-2) = intersections_n;
    
end

intersections__last = intersections_n

intersections_integers_complete = [zeros(1,size(intersections_integers,2)); intersections_integers];

ambiguity_distances_INT_FORM_MAT = abs(intersections_integers_complete - round(intersections_integers_complete));
ambiguity_distances_INT_FORM_mean = mean(ambiguity_distances_INT_FORM_MAT,1)
ambiguity_distances_WAVE_FORM_MAT = exp(1i*2*pi*intersections_integers_complete) - exp(1i*2*pi*round(intersections_integers_complete));
ambiguity_distances_WAVE_FORM = sqrt(sum(ambiguity_distances_WAVE_FORM_MAT.*conj(ambiguity_distances_WAVE_FORM_MAT),1))

fign = 0;



el0 = 50;
az0 = 270;
k0x = sind(az0)*cosd(el0);
k0y = cosd(az0)*cosd(el0);
k0z = sind(el0);
k0 = [k0x; k0y; k0z];

cutoff_ph_ang = 90*pi/180;


%find all s-lines that intersect with the cap by range check
cap_intersections_of_slines = repmat([k0x; k0y],1,length(intersections_inds)) - intersection_line(1:2,intersections_inds);
cap_intersections_of_slines = sqrt(sum(cap_intersections_of_slines.^2,1));
cap_intersections_of_slines = cap_intersections_of_slines <= sin(cutoff_ph_ang);
cap_intersections_of_slines = find(cap_intersections_of_slines);

%from knowing what lines intersect with cap, find all possible DOA ambigs
%that are part of this

s_sel = intersection_line(1:3,intersections_inds(cap_intersections_of_slines));

k_finds = zeros(size(s_sel));
k_finds(1:2,:) = repmat([k0x; k0y],1,size(s_sel,2)) - s_sel(1:2,:);
k_finds(3,:) = sqrt(1- k_finds(1,:).^2 - k_finds(2,:).^2 );

SUBGROUP_signal=@(k) exp ( -1i*2*pi*( xy(:,1)*k(1) +...
                                      xy(:,2)*k(2) ) );

      
                                  
ambiguity_distances_EXPLICIT = zeros(1,size(k_finds,2));
ambiguity_normal_EXPLICIT = zeros(size(xy,1),size(k_finds,2));
for i = 1:size(k_finds,2)
    ambiguity_distances_EXPLICIT(1,i) = norm(SUBGROUP_signal(k0) - SUBGROUP_signal(k_finds(:,i)));
    ambiguity_normal_EXPLICIT(:,i) = (SUBGROUP_signal(k0) - SUBGROUP_signal(k_finds(:,i)))/ambiguity_distances_EXPLICIT(1,i);
end
ambiguity_distances_EXPLICIT
ambiguity_normal_EXPLICIT


tick_font_size = 18;

fign = fign + 1; figure(fign); clf;
% set( gcf, 'Color', 'White', 'Unit', 'Normalized', ...
%     'Position', [0.1,0.1,0.8,0.6] ) ;
% - Build title axes and title.
% axes( 'Position', [0, 0.95, 1, 0.05] ) ;
% set( gca, 'Color', 'None', 'XColor', 'White', 'YColor', 'White' ) ;

subplot(1,1,1);
hold on
h = plot(xy(:,1)*lambda0,xy(:,2)*lambda0, 'ob');
for i=1:(size(xy,1))
plot(xant(i,:)*lambda0, yant(i,:)*lambda0, '*','color',[.8,.6,.6]);
if size(yant,2) > 1
K = convhull(xant(i,:)*lambda0, yant(i,:)*lambda0);
plot(xant(i,K)*lambda0, yant(i,K)*lambda0, '-k');
end
end
hold off
% axis('equal')
lh = legend('Sensor position','Subgroup antennas');
xh = xlabel('x [m]');
yh = ylabel('y [m]');
th = title('MU-radar sensor configuration');
set([xh,yh,th,lh],'Interpreter','latex','fontsize',axis_font_size+8)
axis equal

ax = ancestor(h, 'axes');
ax.XAxis.FontSize = tick_font_size;
ax.YAxis.FontSize = tick_font_size;


fign = fign + 1; figure(fign); clf;
plot(xant', yant', '*','color',[.8,.6,.6]);
hold on
plot(xy(:,1),xy(:,2), 'ob');
hold off
axis('equal')



fign = fign + 1; figure(fign); clf;
% plot(xant', yant', '*');
% hold on
plot(xy(:,1),xy(:,2), 'o');
% hold off
axis('equal')


fign = fign + 1; figure(fign); clf;
set( gcf, 'Color', 'White', 'Unit', 'Normalized', ...
    'Position', [0.1,0.1,0.8,0.6] ) ;
% - Build title axes and title.
axes( 'Position', [0, 0.95, 1, 0.05] ) ;
set( gca, 'Color', 'None', 'XColor', 'White', 'YColor', 'White' ) ;

subplot(1,1,1);
plot(3:Sn,SURVIVORS)
xh = xlabel('Number of sensors included');
yh = ylabel('Number of common plane intersections');
th = title('Intersection plane counts');
set([xh,yh,th],'Interpreter','latex','fontsize',axis_font_size)


fign = fign + 1; figure(fign); clf;
set( gcf, 'Color', 'White', 'Unit', 'Normalized', ...
    'Position', [0.1,0.1,0.8,0.6] ) ;
% - Build title axes and title.
axes( 'Position', [0, 0.95, 1, 0.05] ) ;
set( gca, 'Color', 'None', 'XColor', 'White', 'YColor', 'White' ) ;

subplot(1,1,1);
plot(intersection_line(1,intersections_inds),intersection_line(2,intersections_inds),'.b')
xh = xlabel('$s_{x}$ [1]');
yh = ylabel('$s_{y}$ [1]');
th = title('Intersection lines');
axis([-2,2,-2,2])
set([xh,yh,th],'Interpreter','latex','fontsize',axis_font_size)


% save('MUSIC_DOA_AMBIG_base.mat');

% inds_inside_circle = find(sqrt(sum(intersection_line(:,intersections_inds).^2,1)) < sind(18)*2.5)


fign = fign + 1; figure(fign); clf;
set( gcf, 'Color', 'White', 'Unit', 'Normalized', ...
    'Position', [0.1,0.1,0.8,0.6] ) ;
% - Build title axes and title.
axes( 'Position', [0, 0.95, 1, 0.05] ) ;
set( gca, 'Color', 'None', 'XColor', 'White', 'YColor', 'White' ) ;

subplot(1,1,1);
hold on
for S_ind = 1:length(intersections_inds)
    fprintf('Starting Sind %i of %i\n',S_ind,length(intersections_inds));
    % for S_ind = 3
    s_point = intersection_line(:,intersections_inds(S_ind));
    s_line = repmat(s_point,1,100);
    s_line(3,:) = linspace(-sqrt(4-dot(s_point,s_point)),sqrt(4-dot(s_point,s_point)),100);
    %     s_line(3,:) = linspace(0,sqrt(4-dot(s_point,s_point)),line_resolution);
    if S_ind == 25
        plot3(s_line(1,:),s_line(2,:),s_line(3,:),'.r')
    else
   h = plot3(s_line(1,:),s_line(2,:),s_line(3,:),'.b');
    end
end
hold off

xh = xlabel('$s_{x}$ [1]');
yh = ylabel('$s_{y}$ [1]');
zh = zlabel('$s_{z}$ [1]');
th = title('Solution set $\Omega$');
axis([-2,2,-2,2])
view([-143,53])
set([th],'Interpreter','latex','fontsize',axis_font_size+6)
set([xh,yh,zh],'Interpreter','latex','fontsize',axis_font_size+12)
ax = ancestor(h, 'axes');
ax.XAxis.FontSize = 19;
ax.YAxis.FontSize = 19;
ax.ZAxis.FontSize = 19;



fign = fign + 1; figure(fign); clf;
set( gcf, 'Color', 'White', 'Unit', 'Normalized', ...
    'Position', [0.1,0.1,0.8,0.6] ) ;
% - Build title axes and title.
axes( 'Position', [0, 0.95, 1, 0.05] ) ;
set( gca, 'Color', 'None', 'XColor', 'White', 'YColor', 'White' ) ;

subplot(1,1,1);
hold on
for S_ind = 1:length(intersections_inds)

    s_point = intersection_line(:,intersections_inds(S_ind));
   plot(s_point(1),s_point(2),'.b')
   text(s_point(1)+0.1,s_point(2),sprintf('%.2f',ambiguity_distances_WAVE_FORM(S_ind)));
end
hold off

xh = xlabel('$s_{x}$ [1]');
yh = ylabel('$s_{y}$ [1]');
th = title('Solution set $\Omega$');
axis([-2,2,-2,2])
set([xh,yh,th],'Interpreter','latex','fontsize',axis_font_size)



circ_cutoff_ph_ang_x = sin(cutoff_ph_ang)*cos(linspace(0,2*pi,100));
circ_cutoff_ph_ang_y = sin(cutoff_ph_ang)*sin(linspace(0,2*pi,100));

fign = fign + 1; figure(fign); clf;
set( gcf, 'Color', 'White', 'Unit', 'Normalized', ...
    'Position', [0.1,0.1,0.8,0.6] ) ;
% - Build title axes and title.
axes( 'Position', [0, 0.95, 1, 0.05] ) ;
set( gca, 'Color', 'None', 'XColor', 'White', 'YColor', 'White' ) ;

subplot(1,2,1);
hold on
for S_ind = 1:length(intersections_inds)

    s_point = intersection_line(:,intersections_inds(S_ind));
   plot(s_point(1),s_point(2),'.b')
   text(s_point(1)+0.1,s_point(2),sprintf('%.2f',ambiguity_distances_WAVE_FORM(S_ind)));
end
plot(k0x,k0y,'or')
plot(circ_cutoff_ph_ang_x ,circ_cutoff_ph_ang_y,'-r')
hold off

xh = xlabel('$s_{x}$ [1]');
yh = ylabel('$s_{y}$ [1]');
th = title('Solution set $\Omega$');
axis([-2,2,-2,2])
set([xh,yh,th],'Interpreter','latex','fontsize',axis_font_size)

subplot(1,2,2);
hold on
plot(k0x,k0y,'or')
for i = 1:size(k_finds,2)
   plot(k_finds(1,i),k_finds(2,i),'.b')
   text(k_finds(1,i)+0.1,k_finds(2,i),sprintf('%.2f',ambiguity_distances_EXPLICIT(i)));
end
hold off

xh = xlabel('$k_{x}$ [1]');
yh = ylabel('$k_{y}$ [1]');
th = title('Explicit ambiguities $\Omega(\mathbf{k})$');
axis([-1,1,-1,1])
set([xh,yh,th],'Interpreter','latex','fontsize',axis_font_size)


##### SOURCE END #####
--></body></html>